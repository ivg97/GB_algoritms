"""
Задание 3.

Для этой задачи:
1) придумайте 2-3 решения (не менее двух) разной!! сложности
2) оцените сложность каждого решения в нотации О-большое
3) сделайте вывод, какое решение эффективнее и почему

Сама задача:
Имеется хранилище с информацией о компаниях: название и годовая прибыль.
Для реализации хранилища можно применить любой подход,
который вы придумаете, например, реализовать словарь.
Реализуйте поиск трех компаний с наибольшей годовой прибылью.
Выведите результат.

Примечание:
Без выполнения пунктов 2 и 3 задание считается нерешенным. Пункты 2 и 3 можно выполнить
через строки документации в самом коде.
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.

Задание творческое. Здесь нет жестких требований к выполнению.
"""



repository = (
    ('WalMart', 524000),
    ('State Grid Corporation of China', 387000),
    ('Sinopec Group', 369200),
    ('China National Petroleum', 364100),
    ('Saudi Aramco', 329800),
    ('Royal Dutch Shell', 311600),
    ('Toyota', 280000),
    ('BP', 278400),
    ('Volkswagen', 275200),
    ('Exxon Mobil', 265700),
)                                                       # O(1)

"""
1 -------- O(n^2)
"""
max_v = list(i[1] for i in repository)                    # O(n)
max_v.sort(reverse=True)                                  # O(1)
max_ = max_v[:3]                                          # O(1)

for i in repository:                                    # O(n)
    for j in max_:                                      # O(n)
        if i[1] == j:                                   # O(1)
            max_.pop(max_.index(j))                     # O(1)
            max_.append(i)                              # O(1)
print(max_)                                             # O(1)



"""
2 ----------- O(n)
"""

res = list()                                                    # O(n)
finish_res = list()                                             # O(n)
value_repository = list(i[1] for i in repository)               # O(n)
for _ in range(3):                                              # O(n)
    val = max(value_repository)                                 # O(n)
    res.append(val)                                             # 0(1)
    value_repository.remove(val)                                # O(n)

for i in repository:                                            # O(n)
    if i[1] in res:                                             # O(n)
        finish_res.append(i)                                    # O(1)
print(finish_res)                                               # O(1)

'''
Вывод: я бы предподчел второй из представленных решений. Так как
сложность второго варианта О(n), то есть линейная, а у первого варианта квадратичная, следовательно 
у второго варианта решения времени для выполнения программы требуется меньше.
'''
